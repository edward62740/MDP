
#include "ICM20948.h"

#define X 0
#define Y 1
#define Z 2
/**
 * Reference and Inspiration:
 * https://github.com/drcpattison/ICM-20948/blob/master/src/ICM20948.h
 * https://github.com/mokhwasomssi/stm32f4_hal_icm20948_lib/blob/master/mokhwa_ICM20948.h
 * https://github.com/mokhwasomssi/stm32f4_hal_icm20948_lib/blob/master/mokhwa_ICM20948_REGISTER.h
 *
 * naming convention:
 * device_name__(info__)(name__)Type
 *
*/
#define ICM20948__I2C_SLAVE_ADDRESS_1 0x68
#define ICM20948__I2C_SLAVE_ADDRESS_2 0x69

#define ICM20948__USER_BANK_ALL__REG_BANK_SEL__REGISTER 0x7F

#define ICM20948__USER_BANK_0__WHO_AM_I__REGISTER 0x00
#define ICM20948__USER_BANK_0__USER_CTRL__REGISTER 0x03
#define ICM20948__USER_BANK_0__LP_CONFIG__REGISTER 0x05
#define ICM20948__USER_BANK_0__PWR_MGMT_1__REGISTER 0x06
#define ICM20948__USER_BANK_0__PWR_MGMT_2__REGISTER 0x07
#define ICM20948__USER_BANK_0__INT_PIN_CFG__REGISTER 0x0F
#define ICM20948__USER_BANK_0__INT_ENABLE__REGISTER 0x10
#define ICM20948__USER_BANK_0__INT_ENABLE_1__REGISTER 0x11
#define ICM20948__USER_BANK_0__INT_ENABLE_2__REGISTER 0x12
#define ICM20948__USER_BANK_0__INT_ENABLE_3__REGISTER 0x13
#define ICM20948__USER_BANK_0__I2C_MST_STATUS__REGISTER 0x17
#define ICM20948__USER_BANK_0__INT_STATUS__REGISTER 0x19
#define ICM20948__USER_BANK_0__INT_STATUS__REGISTER 0x19
#define ICM20948__USER_BANK_0__INT_STATUS_1__REGISTER 0x1A
#define ICM20948__USER_BANK_0__INT_STATUS_2__REGISTER 0x1B
#define ICM20948__USER_BANK_0__INT_STATUS_3__REGISTER 0x1C
#define ICM20948__USER_BANK_0__DELAY_TIMEH__REGISTER 0x28
#define ICM20948__USER_BANK_0__DELAY_TIMEL__REGISTER 0x29
#define ICM20948__USER_BANK_0__ACCEL_XOUT_H__REGISTER 0x2D
#define ICM20948__USER_BANK_0__ACCEL_XOUT_L__REGISTER 0x2E
#define ICM20948__USER_BANK_0__ACCEL_YOUT_H__REGISTER 0x2F
#define ICM20948__USER_BANK_0__ACCEL_YOUT_L__REGISTER 0x30
#define ICM20948__USER_BANK_0__ACCEL_ZOUT_H__REGISTER 0x31
#define ICM20948__USER_BANK_0__ACCEL_ZOUT_L__REGISTER 0x32
#define ICM20948__USER_BANK_0__GYRO_XOUT_H__REGISTER 0x33
#define ICM20948__USER_BANK_0__GYRO_XOUT_L__REGISTER 0x34
#define ICM20948__USER_BANK_0__GYRO_YOUT_H__REGISTER 0x35
#define ICM20948__USER_BANK_0__GYRO_YOUT_L__REGISTER 0x36
#define ICM20948__USER_BANK_0__GYRO_ZOUT_H__REGISTER 0x37
#define ICM20948__USER_BANK_0__GYRO_ZOUT_L__REGISTER 0x38
#define ICM20948__USER_BANK_0__TEMP_OUT_H__REGISTER 0x39
#define ICM20948__USER_BANK_0__TEMP_OUT_L__REGISTER 0x3A
#define ICM20948__USER_BANK_0__EXT_SENS_DATA_00__REGISTER 0x3B
#define ICM20948__USER_BANK_0__EXT_SENS_DATA_01__REGISTER 0x3C
#define ICM20948__USER_BANK_0__EXT_SENS_DATA_02__REGISTER 0x3D
#define ICM20948__USER_BANK_0__EXT_SENS_DATA_03__REGISTER 0x3E
#define ICM20948__USER_BANK_0__EXT_SENS_DATA_04__REGISTER 0x3F
#define ICM20948__USER_BANK_0__EXT_SENS_DATA_05__REGISTER 0x40
#define ICM20948__USER_BANK_0__EXT_SENS_DATA_06__REGISTER 0x41
#define ICM20948__USER_BANK_0__EXT_SENS_DATA_07__REGISTER 0x42
#define ICM20948__USER_BANK_0__EXT_SENS_DATA_08__REGISTER 0x43
#define ICM20948__USER_BANK_0__EXT_SENS_DATA_09__REGISTER 0x44
#define ICM20948__USER_BANK_0__EXT_SENS_DATA_10__REGISTER 0x45
#define ICM20948__USER_BANK_0__EXT_SENS_DATA_11__REGISTER 0x46
#define ICM20948__USER_BANK_0__EXT_SENS_DATA_12__REGISTER 0x47
#define ICM20948__USER_BANK_0__EXT_SENS_DATA_13__REGISTER 0x48
#define ICM20948__USER_BANK_0__EXT_SENS_DATA_14__REGISTER 0x49
#define ICM20948__USER_BANK_0__EXT_SENS_DATA_15__REGISTER 0x4A
#define ICM20948__USER_BANK_0__EXT_SENS_DATA_16__REGISTER 0x4B
#define ICM20948__USER_BANK_0__EXT_SENS_DATA_17__REGISTER 0x4C
#define ICM20948__USER_BANK_0__EXT_SENS_DATA_18__REGISTER 0x4D
#define ICM20948__USER_BANK_0__EXT_SENS_DATA_19__REGISTER 0x4E
#define ICM20948__USER_BANK_0__EXT_SENS_DATA_20__REGISTER 0x4F
#define ICM20948__USER_BANK_0__EXT_SENS_DATA_21__REGISTER 0x50
#define ICM20948__USER_BANK_0__EXT_SENS_DATA_22__REGISTER 0x51
#define ICM20948__USER_BANK_0__EXT_SENS_DATA_23__REGISTER 0x52
#define ICM20948__USER_BANK_0__FIFO_EN_1__REGISTER 0x66
#define ICM20948__USER_BANK_0__FIFO_EN_2__REGISTER 0x67
#define ICM20948__USER_BANK_0__FIFO_RST__REGISTER 0x68
#define ICM20948__USER_BANK_0__FIFO_MODE__REGISTER 0x69
#define ICM20948__USER_BANK_0__FIFO_COUNTH__REGISTER 0x70
#define ICM20948__USER_BANK_0__FIFO_COUNTL__REGISTER 0x71
#define ICM20948__USER_BANK_0__FIFO_R_W__REGISTER 0x72
#define ICM20948__USER_BANK_0__DATA_RDY_STATUS__REGISTER 0x74
#define ICM20948__USER_BANK_0__FIFO_CFG__REGISTER 0x76

#define ICM20948__USER_BANK_1__SELF_TEST_X_GYRO__REGISTER 0x02
#define ICM20948__USER_BANK_1__SELF_TEST_Y_GYRO__REGISTER 0x03
#define ICM20948__USER_BANK_1__SELF_TEST_Z_GYRO__REGISTER 0x04
#define ICM20948__USER_BANK_1__SELF_TEST_X_ACCEL__REGISTER 0x0E
#define ICM20948__USER_BANK_1__SELF_TEST_Y_ACCEL__REGISTER 0x0F
#define ICM20948__USER_BANK_1__SELF_TEST_Z_ACCEL__REGISTER 0x10
#define ICM20948__USER_BANK_1__XA_OFFSET_H__REGISTER 0x14
#define ICM20948__USER_BANK_1__XA_OFFSET_L__REGISTER 0x15
#define ICM20948__USER_BANK_1__YA_OFFSET_H__REGISTER 0x17
#define ICM20948__USER_BANK_1__YA_OFFSET_L__REGISTER 0x18
#define ICM20948__USER_BANK_1__ZA_OFFSET_H__REGISTER 0x1A
#define ICM20948__USER_BANK_1__ZA_OFFSET_L__REGISTER 0x1B
#define ICM20948__USER_BANK_1__TIMEBASE_CORRECTION_PLL__REGISTER 0x28

#define ICM20948__USER_BANK_2__GYRO_SMPLRT_DIV__REGISTER 0x00
#define ICM20948__USER_BANK_2__GYRO_CONFIG_1__REGISTER 0x01
#define ICM20948__USER_BANK_2__GYRO_CONFIG_2__REGISTER 0x02
#define ICM20948__USER_BANK_2__XG_OFFSET_H__REGISTER 0x03
#define ICM20948__USER_BANK_2__XG_OFFSET_L__REGISTER 0x04
#define ICM20948__USER_BANK_2__YG_OFFSET_H__REGISTER 0x05
#define ICM20948__USER_BANK_2__YG_OFFSET_L__REGISTER 0x06
#define ICM20948__USER_BANK_2__ZG_OFFSET_H__REGISTER 0x07
#define ICM20948__USER_BANK_2__ZG_OFFSET_L__REGISTER 0x08
#define ICM20948__USER_BANK_2__ODR_ALIGN_EN__REGISTER 0x09
#define ICM20948__USER_BANK_2__ACCEL_SMPLRT_DIV_1__REGISTER 0x10
#define ICM20948__USER_BANK_2__ACCEL_SMPLRT_DIV_2__REGISTER 0x11
#define ICM20948__USER_BANK_2__ACCEL_INTEL_CTRL__REGISTER 0x12
#define ICM20948__USER_BANK_2__ACCEL_WOM_THR__REGISTER 0x13
#define ICM20948__USER_BANK_2__ACCEL_CONFIG__REGISTER 0x14
#define ICM20948__USER_BANK_2__ACCEL_CONFIG_2__REGISTER 0x15
#define ICM20948__USER_BANK_2__FSYNC_CONFIG__REGISTER 0x52
#define ICM20948__USER_BANK_2__TEMP_CONFIG__REGISTER 0x53
#define ICM20948__USER_BANK_2__MOD_CTRL_USR__REGISTER 0x54

#define ICM20948__USER_BANK_3__I2C_MST_ODR_CONFIG__REGISTER 0x00
#define ICM20948__USER_BANK_3__I2C_MST_CTRL__REGISTER 0x01
#define ICM20948__USER_BANK_3__I2C_MST_DELAY_CTRL__REGISTER 0x02
#define ICM20948__USER_BANK_3__I2C_SLV0_ADDR__REGISTER 0x03
#define ICM20948__USER_BANK_3__I2C_SLV0_REG__REGISTER 0x04
#define ICM20948__USER_BANK_3__I2C_SLV0_CTRL__REGISTER 0x05
#define ICM20948__USER_BANK_3__I2C_SLV0_DO__REGISTER 0x06
#define ICM20948__USER_BANK_3__I2C_SLV1_ADDR__REGISTER 0x07
#define ICM20948__USER_BANK_3__I2C_SLV1_REG__REGISTER 0x08
#define ICM20948__USER_BANK_3__I2C_SLV1_CTRL__REGISTER 0x09
#define ICM20948__USER_BANK_3__I2C_SLV1_DO__REGISTER 0x0A
#define ICM20948__USER_BANK_3__I2C_SLV2_ADDR__REGISTER 0x0B
#define ICM20948__USER_BANK_3__I2C_SLV2_REG__REGISTER 0x0C
#define ICM20948__USER_BANK_3__I2C_SLV2_CTRL__REGISTER 0x0D
#define ICM20948__USER_BANK_3__I2C_SLV2_DO__REGISTER 0x0E
#define ICM20948__USER_BANK_3__I2C_SLV3_ADDR__REGISTER 0x0F
#define ICM20948__USER_BANK_3__I2C_SLV3_REG__REGISTER 0x10
#define ICM20948__USER_BANK_3__I2C_SLV3_CTRL__REGISTER 0x11
#define ICM20948__USER_BANK_3__I2C_SLV3_DO__REGISTER 0x12
#define ICM20948__USER_BANK_3__I2C_SLV4_ADDR__REGISTER 0x13
#define ICM20948__USER_BANK_3__I2C_SLV4_REG__REGISTER 0x14
#define ICM20948__USER_BANK_3__I2C_SLV4_CTRL__REGISTER 0x15
#define ICM20948__USER_BANK_3__I2C_SLV4_DO__REGISTER 0x16
#define ICM20948__USER_BANK_3__I2C_SLV4_DI__REGISTER 0x17
#define X_HIGH_BYTE 0
#define X_LOW_BYTE 1
#define Y_HIGH_BYTE 2
#define Y_LOW_BYTE 3
#define Z_HIGH_BYTE 4
#define Z_LOW_BYTE 5

#define T_HIGH_BYTE 0
#define T_LOW_BYTE 1

#define ONE_BYTE 8

#define ICM20948_RESET 0x80
#define ICM20948_DISABLE_SENSORS 0x00
#define ICM20948_ENABLE_SENSORS 0x3F
#define ICM20948_AUTO_SELECT_CLOCK 0x01

uint8_t readGyroDataZ[2];

HAL_StatusTypeDef _ICM20948_SelectUserBank(I2C_HandleTypeDef * hi2c, uint8_t const selectI2cAddress, int userBankNum) {
	HAL_StatusTypeDef status = HAL_OK;
	uint8_t writeData = userBankNum << BIT_4;
	uint8_t deviceI2CAddress = (selectI2cAddress == 0)? ICM20948__I2C_SLAVE_ADDRESS_1: ICM20948__I2C_SLAVE_ADDRESS_2;

	status = HAL_I2C_Mem_Write(
			hi2c,
			deviceI2CAddress << 1,
			ICM20948__USER_BANK_ALL__REG_BANK_SEL__REGISTER,
			I2C_MEMADD_SIZE_8BIT,
			&writeData,
			I2C_MEMADD_SIZE_8BIT,
			10);

	return status;
}

HAL_StatusTypeDef _ICM20948_WriteByte(I2C_HandleTypeDef * hi2c, uint8_t const selectI2cAddress, uint8_t const registerAddress, uint8_t writeData) {
	HAL_StatusTypeDef status = HAL_OK;
	uint8_t deviceI2CAddress = (selectI2cAddress == 0)? ICM20948__I2C_SLAVE_ADDRESS_1: ICM20948__I2C_SLAVE_ADDRESS_2;

	status = HAL_I2C_Mem_Write(
			hi2c,
			deviceI2CAddress << 1,
			registerAddress,
			I2C_MEMADD_SIZE_8BIT,
			&writeData,
			I2C_MEMADD_SIZE_8BIT,
			10);

	return status;
}

HAL_StatusTypeDef _ICM20948_ReadByte(I2C_HandleTypeDef * hi2c, uint8_t const selectI2cAddress, uint8_t const registerAddress, uint8_t * readData) {
	HAL_StatusTypeDef status = HAL_OK;
	uint8_t deviceI2CAddress = (selectI2cAddress == 0)? ICM20948__I2C_SLAVE_ADDRESS_1: ICM20948__I2C_SLAVE_ADDRESS_2;

	status = HAL_I2C_Mem_Read(
			hi2c,
			deviceI2CAddress << 1,
			registerAddress,
			I2C_MEMADD_SIZE_8BIT,
			readData,
			I2C_MEMADD_SIZE_8BIT,
			10);

	return status;
}

HAL_StatusTypeDef _ICM20948_BrustRead(I2C_HandleTypeDef * hi2c, uint8_t const selectI2cAddress, uint8_t const startAddress, uint16_t const amountOfRegistersToRead, uint8_t * readData) {
	HAL_StatusTypeDef status = HAL_OK;
	uint8_t deviceI2CAddress = (selectI2cAddress == 0)? ICM20948__I2C_SLAVE_ADDRESS_1: ICM20948__I2C_SLAVE_ADDRESS_2;

	status = HAL_I2C_Mem_Read(
			hi2c,
			deviceI2CAddress << 1,
			startAddress,
			I2C_MEMADD_SIZE_8BIT,
			readData,
			amountOfRegistersToRead,
			10);

	return status;
}

uint8_t ICM20948_isI2cAddress1(I2C_HandleTypeDef * hi2c) {
	HAL_StatusTypeDef addressStatus = HAL_I2C_IsDeviceReady(hi2c, ICM20948__I2C_SLAVE_ADDRESS_1 << 1, 2, 10);

	if (addressStatus == HAL_OK) {
		return 1;
	}

	return 0;
}

uint8_t ICM20948_isI2cAddress2(I2C_HandleTypeDef * hi2c) {
	HAL_StatusTypeDef addressStatus = HAL_I2C_IsDeviceReady(hi2c, ICM20948__I2C_SLAVE_ADDRESS_2 << 1, 2, 10);

	if (addressStatus == HAL_OK) {
		return 1;
	}

	return 0;
}

void ICM20948_init(I2C_HandleTypeDef * hi2c, uint8_t const selectI2cAddress, uint8_t const selectGyroSensitivity) {
	HAL_StatusTypeDef status = HAL_OK;

	status = _ICM20948_SelectUserBank(hi2c, selectI2cAddress, USER_BANK_0);

	status = _ICM20948_WriteByte(
			hi2c,
			selectI2cAddress,
			ICM20948__USER_BANK_0__PWR_MGMT_1__REGISTER,
			ICM20948_RESET);

	HAL_Delay(200);

	status = _ICM20948_WriteByte(
			hi2c,
			selectI2cAddress,
			ICM20948__USER_BANK_0__PWR_MGMT_1__REGISTER,
			ICM20948_AUTO_SELECT_CLOCK);
	/* status = _ICM20948_WriteByte(
			hi2c,
			selectI2cAddress,
			ICM20948__USER_BANK_0__PWR_MGMT_2__REGISTER,
			ICM20948_DISABLE_SENSORS); */ // For some reason this needs to be tested

	// disable accelerometer
	status = _ICM20948_WriteByte(
				hi2c,
				selectI2cAddress,
				ICM20948__USER_BANK_0__PWR_MGMT_2__REGISTER,
				0x38);

	status = _ICM20948_SelectUserBank(hi2c, selectI2cAddress, USER_BANK_2);

	status = _ICM20948_WriteByte(
			hi2c,
			selectI2cAddress,
			ICM20948__USER_BANK_2__GYRO_CONFIG_1__REGISTER,
			3 << GYRO_DLPFCFG_BIT|selectGyroSensitivity << BIT_1|EN_GRYO_DLPF << GYRO_FCHOICE_BIT);

//	status = _ICM20948_WriteByte(
//			hi2c,
//			selectI2cAddress,
//			ICM20948__USER_BANK_2__TEMP_CONFIG__REGISTER,
//			0x03); // Don't understand how this works

	status = _ICM20948_WriteByte(
			hi2c,
			selectI2cAddress,
			ICM20948__USER_BANK_2__GYRO_SMPLRT_DIV__REGISTER,
			0x04); // Don't understand how this works

//	status = _ICM20948_WriteByte(
//			hi2c,
//			selectI2cAddress,
//			ICM20948__USER_BANK_2__ACCEL_CONFIG__REGISTER,
//			0x03<< BIT_3|selectAccelSensitivity << BIT_1|0x01 << BIT_0);
////
//	status = _ICM20948_WriteByte(
//			hi2c,
//			selectI2cAddress,
//			ICM20948__USER_BANK_2__ACCEL_SMPLRT_DIV_2__REGISTER,
//			0x04); // Don't understand how this works


	status = _ICM20948_SelectUserBank(hi2c, selectI2cAddress, USER_BANK_0);
//
	status = _ICM20948_WriteByte(
			hi2c,
			selectI2cAddress,
			ICM20948__USER_BANK_0__INT_PIN_CFG__REGISTER,
			0x02); // Don't understand how this works

//	status = _AK09918_WriteByte(hi2c, AK09916__CNTL2__REGISTER, 0x08);
}

void ICM20948_readGyroscope_allAxises(I2C_HandleTypeDef * hi2c, uint8_t const selectI2cAddress, uint8_t const selectGyroSensitivity, int16_t readings[3]) {
//	HAL_StatusTypeDef status = HAL_OK;
	uint8_t readData[6];

//	status = _ICM20948_SelectUserBank(hi2c, selectI2cAddress, USER_BANK_0);

//	status =
	_ICM20948_BrustRead(hi2c, selectI2cAddress, ICM20948__USER_BANK_0__GYRO_XOUT_H__REGISTER, 6, readData);

	readings[X] = readData[X_HIGH_BYTE]<<8|readData[X_LOW_BYTE];
	readings[Y] = readData[Y_HIGH_BYTE]<<8|readData[Y_LOW_BYTE];
	readings[Z] = readData[Z_HIGH_BYTE]<<8|readData[Z_LOW_BYTE];

	switch (selectGyroSensitivity) {
		case GYRO_FULL_SCALE_250DPS:
			readings[X] /= GRYO_SENSITIVITY_SCALE_FACTOR_250DPS;
			readings[Y] /= GRYO_SENSITIVITY_SCALE_FACTOR_250DPS;
			readings[Z] /= GRYO_SENSITIVITY_SCALE_FACTOR_250DPS;
			break;
		case GYRO_FULL_SCALE_500DPS:
			readings[X] /= GRYO_SENSITIVITY_SCALE_FACTOR_500DPS;
			readings[Y] /= GRYO_SENSITIVITY_SCALE_FACTOR_500DPS;
			readings[Z] /= GRYO_SENSITIVITY_SCALE_FACTOR_500DPS;
			break;
		case GYRO_FULL_SCALE_1000DPS:
			readings[X] /= GRYO_SENSITIVITY_SCALE_FACTOR_1000DPS;
			readings[Y] /= GRYO_SENSITIVITY_SCALE_FACTOR_1000DPS;
			readings[Z] /= GRYO_SENSITIVITY_SCALE_FACTOR_1000DPS;
			break;
		case GYRO_FULL_SCALE_2000DPS:
			readings[X] /= GRYO_SENSITIVITY_SCALE_FACTOR_2000DPS;
			readings[Y] /= GRYO_SENSITIVITY_SCALE_FACTOR_2000DPS;
			readings[Z] /= GRYO_SENSITIVITY_SCALE_FACTOR_2000DPS;
			break;
	}
}

void ICM20948_readGyroscope_Z(I2C_HandleTypeDef * hi2c, uint8_t const selectI2cAddress, uint8_t const selectGyroSensitivity, int16_t *gyroZ) {
//	HAL_StatusTypeDef status = HAL_OK;
//	status =
//	_ICM20948_SelectUserBank(hi2c, selectI2cAddress, USER_BANK_0);  no need, already at bank 0
//	status =
	_ICM20948_BrustRead(hi2c, selectI2cAddress, ICM20948__USER_BANK_0__GYRO_ZOUT_H__REGISTER, 2, readGyroDataZ);

	*gyroZ = readGyroDataZ[0]<<8 | readGyroDataZ[1];
	*gyroZ /= GRYO_SENSITIVITY_SCALE_FACTOR_250DPS;
}

void ICM20948_readAccelerometer_allAxises(I2C_HandleTypeDef * hi2c, uint8_t const selectI2cAddress, uint8_t const selectAccelSensitivity, int16_t readings[3]) {
//	HAL_StatusTypeDef status = HAL_OK;
	uint8_t readData[6];

//	status = _ICM20948_SelectUserBank(hi2c, selectI2cAddress, USER_BANK_0);

	//status =
	_ICM20948_BrustRead(hi2c, selectI2cAddress, ICM20948__USER_BANK_0__ACCEL_XOUT_H__REGISTER, 6, readData);

	readings[X] = readData[X_HIGH_BYTE]<<8|readData[X_LOW_BYTE];
	readings[Y] = readData[Y_HIGH_BYTE]<<8|readData[Y_LOW_BYTE];
	readings[Z] = readData[Z_HIGH_BYTE]<<8|readData[Z_LOW_BYTE];

	switch (selectAccelSensitivity) {
		case ACCEL_FULL_SCALE_2G:
			readings[X] /= ACCEL_SENSITIVITY_SCALE_FACTOR_2G;
			readings[Y] /= ACCEL_SENSITIVITY_SCALE_FACTOR_2G;
			readings[Z] /= ACCEL_SENSITIVITY_SCALE_FACTOR_2G;
			break;
		case ACCEL_FULL_SCALE_4G:
			readings[X] /= ACCEL_SENSITIVITY_SCALE_FACTOR_4G;
			readings[Y] /= ACCEL_SENSITIVITY_SCALE_FACTOR_4G;
			readings[Z] /= ACCEL_SENSITIVITY_SCALE_FACTOR_4G;
			break;
		case ACCEL_FULL_SCALE_8G:
			readings[X] /= ACCEL_SENSITIVITY_SCALE_FACTOR_8G;
			readings[Y] /= ACCEL_SENSITIVITY_SCALE_FACTOR_8G;
			readings[Z] /= ACCEL_SENSITIVITY_SCALE_FACTOR_8G;
			break;
		case ACCEL_FULL_SCALE_16G:
			readings[X] /= ACCEL_SENSITIVITY_SCALE_FACTOR_16G;
			readings[Y] /= ACCEL_SENSITIVITY_SCALE_FACTOR_16G;
			readings[Z] /= ACCEL_SENSITIVITY_SCALE_FACTOR_16G;
			break;
	}
}

void ICM20948_readTemperature(I2C_HandleTypeDef * hi2c, uint8_t const selectI2cAddress, int16_t * reading) {
  HAL_StatusTypeDef status = HAL_OK;
  uint8_t readData[2];

  status = _ICM20948_SelectUserBank(hi2c, selectI2cAddress, USER_BANK_0);

  status = _ICM20948_BrustRead(hi2c, selectI2cAddress, ICM20948__USER_BANK_0__TEMP_OUT_H__REGISTER, 2, readData);

  *reading = readData[T_HIGH_BYTE]<<8|readData[T_LOW_BYTE];
}

HAL_StatusTypeDef _AK09918_BrustRead(I2C_HandleTypeDef * hi2c, uint8_t const startAddress, uint16_t const amountOfRegistersToRead, uint8_t * readData) {
	HAL_StatusTypeDef status = HAL_OK;

	status = HAL_I2C_Mem_Read(
			hi2c,
			AK09918__I2C_SLAVE_ADDRESS << 1,
			startAddress,
			I2C_MEMADD_SIZE_8BIT,
			readData,
			amountOfRegistersToRead,
			0xFFFF);

	return status;
}

HAL_StatusTypeDef _AK09918_WriteByte(I2C_HandleTypeDef * hi2c, uint8_t const registerAddress, uint8_t writeData) {
	HAL_StatusTypeDef status = HAL_OK;

	status = HAL_I2C_Mem_Write(
			hi2c,
			AK09918__I2C_SLAVE_ADDRESS << 1,
			registerAddress,
			I2C_MEMADD_SIZE_8BIT,
			&writeData,
			I2C_MEMADD_SIZE_8BIT,
			10);

	return status;
}

void ICM20948_readMagnetometer_allAxises(I2C_HandleTypeDef * hi2c, int16_t readings[3]) {
	HAL_StatusTypeDef status = HAL_OK;
	uint8_t readData[6];

	status = _AK09918_BrustRead(hi2c, AK09916__XOUT_H__REGISTER, 6, readData);

	readings[X] = readData[X_HIGH_BYTE]<<8|readData[X_LOW_BYTE];
	readings[Y] = readData[Y_HIGH_BYTE]<<8|readData[Y_LOW_BYTE];
	readings[Z] = readData[Z_HIGH_BYTE]<<8|readData[Z_LOW_BYTE];

	readings[X] *= MAG_SENSITIVITY_SCALE_FACTOR;
	readings[Y] *= MAG_SENSITIVITY_SCALE_FACTOR;
	readings[Z] *= MAG_SENSITIVITY_SCALE_FACTOR;
}
